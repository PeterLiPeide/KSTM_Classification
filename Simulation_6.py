# Simulation 1 for RPSTM Ensemble

import os
import time
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.metrics import zero_one_loss
from sklearn.metrics import confusion_matrix

print("This is the result of simuation model HNR3 from my paper Random Projection STM\n \
       The model specification can be found in the paper. \n \
        This result is generated by using RPSTM package!!!!!!!!!!!!!! \n \
        #####################################################################\n \
       sigma1 = identity, sigma2, sigma4 = AR(0.7), sigma3 = Brownian\n \
       The setup of this simulation: \n \
        1. Generate 200 data, 100 from class 1 and 100 from class -1 (iid)\n \
            Rank 3 tensor 4 modes,   N(0 , sigma1, 2, 3, 4) + N (1, sigma1, 2, 3, 4)\
        2.  Use train / test split function from sklearn to take 80 percent data as training\n \
            The spliting is done with stratified sampling (Balanced classification)\n \
        3. Repeat for 50 times to get testing errors and std\n \
        4. Ensemble of 10 random projections\n \
        5. Projection [50, 50, 50, 50] -> [30, 30, 30, 30]")


"""
Load my package after seting work directory
"""
wkdir = '/mnt/home/lipeide/RP_STM/Simulation'
os.chdir(wkdir)
import RPSTM
##################################################################################################################################################
"""
Generate Data
"""
np.random.seed(9001)
# Creating AR matrix
def AR_Matrix(rho, n):
    cov = np.arange(n*n).reshape(n, n)
    for i in range(n):
        for j in range(n):
            cov[i, j] = rho ** np.abs(i - j)
    return cov

#
cov3 = np.arange(2500).reshape(50, 50)
for i in range(50):
    for j in range(50):
        cov3[i,j] = min(i + 1, j + 1)
#
cov1 = np.diag(np.ones(50))
cov2 = AR_Matrix(0.7, 50)
cov4 = AR_Matrix(0.7, 50)

# Generate variables
def Generate_SmallNormal_Tensor(mean, Num_rank, cov1, cov2, cov3, cov4):
    total = 0
    for i in range(Num_rank):
        mode1 = np.random.multivariate_normal(mean, cov1)
        mdoe2 = np.random.multivariate_normal(mean, cov2)
        mode3 = np.random.multivariate_normal(mean, cov3)
        mode4 = np.random.multivariate_normal(mean, cov4)
        temp = np.tensordot(mode1, mdoe2, axes=0)
        temp = np.tensordot(temp, mode3, axes=0)
        temp = np.tensordot(temp, mode4, axes = 0)
        total += temp
    return total
#
# One can choose to generate random uniform tensor or normal tensor
data_size = 100
Num_Rank = 3
D_dim = 50
# Set P and D for Random Projection, 3 mode tensors
P = [30, 30, 30, 30]
D = [D_dim, D_dim, D_dim, D_dim]

# Generating Random Tensor
n_ensemble = 10


Class_data = []
for i in range(data_size):
    Class_data += [Generate_SmallNormal_Tensor(np.zeros(D_dim), Num_Rank, cov1, cov2, cov3, cov4), \
    Generate_SmallNormal_Tensor(np.ones(D_dim), Num_Rank, cov1, cov2, cov3, cov4)]

data_label = np.array([1, -1] * data_size)


# Model Setup
Kernel_Gamma = np.array([1, 1, 1, 1])
lambda_vec = 0.5

# ########################################################################################

X = pd.DataFrame(index=np.arange(len(Class_data)))
Y = pd.DataFrame(index=X.index, data=data_label)


iteration_num = 0
Error_Rate = []
Training_Time = []
while iteration_num < 50:
    iteration_num += 1
    
    # Train Test Split
    Xtrain, Xtest, Ytrain, Ytest = train_test_split(X, Y, test_size = 0.2, stratify=Y)
    Xtrain, Xtest = Xtrain.index.to_list(), Xtest.index.to_list()

    Tensor_train = [Class_data[i] for i in Xtrain]
    Tensor_test = [Class_data[j] for j in Xtest]
    Ytrain, Ytest = Ytrain.values.reshape(len(Ytrain)), Ytest.values.reshape(len(Ytest))
    
    start = time.time()
    # Model training
    mymodel = RPSTM.STM_Classifier(Num_Rank, D, P, n_ensemble)
    mymodel.fit(Tensor_train, Ytrain, Kernel_Gamma, lambda_vec)
    end = time.time()
    
    Training_Time.append((end - start))

    pred = mymodel.pred(Tensor_test, alpha=0)
    predict1 = zero_one_loss(Ytest, pred, normalize=True)
    print("The confusion matrix of round {0} is \n {1}".format(iteration_num, confusion_matrix(Ytest, pred)))
    Error_Rate.append(predict1)

print(" ######################################################## \n \
        Simulation Result: \n\
        1. Training Time (Avg, Std): {0}\n\
        2. Error rate (0-1 loss Avg, Std): {1}".\
            format([np.mean(Training_Time), np.std(Training_Time)], [np.mean(Error_Rate), np.std(Error_Rate)]))

print("One of the training procedure is tracked! \n")
plot_file = 'Simulation_6.pdf'
mymodel.Plot_history(plot_file)







